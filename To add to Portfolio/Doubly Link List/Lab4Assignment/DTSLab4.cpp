////////////////////////////////////////////////////////////////////////////////////////////////
// File :			DTSLab4.cpp
// Author :			Rodney Stoeffler
// Created :		06.03.08
// Last Modified :	07.01.09
// Purpose :		Driver Program for the DLList and DLLIter classes.
// Notes :			Property of Full Sail University, Data Structures Course.
//					DON'T CHANGE THIS FILE. change your code if something is not working
//					Program Output should match the Lab Document
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
// LEAK DETECTION
////////////////////////////////////////////////////////////////////////////////////////////////
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>

////////////////////////////////////////////////////////////////////////////////////////////////
// INCLUDES
////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <string>
using namespace std;
#include "DLList.h"		// Include the DLList header.

////////////////////////////////////////////////////////////////////////////////////////////////
// Function :	forward
// Parameters :	list - the DLList to print
// Return :		void
////////////////////////////////////////////////////////////////////////////////////////////////
template<typename Type>
void forward(DLList<Type>& list)
{
	DLLIter<Type> iter(list);
	cout << "FWD { ";
	for(iter.beginHead(); !iter.end(); ++iter)
		cout << iter.current() << ' ';
	cout << "}\n";
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Function :	backward
// Parameters :	list - the DLList to print
// Return :		void
////////////////////////////////////////////////////////////////////////////////////////////////
template<typename Type>
void backward(DLList<Type>& list)
{
	DLLIter<Type> iter(list);
	cout << "BWD { ";
	for(iter.beginTail(); !iter.end(); --iter)
		cout << iter.current() << ' ';
	cout << "}\n";
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Function :	main
// Parameters : argc - the number of command line arguments
//				argv - the array of command line arguments
// Return :		int - 0 for success
////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char ** argv)
{
////////////////////////////////////////////////////////////////////////////////////////////////
// LEAK DETECTION
////////////////////////////////////////////////////////////////////////////////////////////////
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	// this function call will set a breakpoint at the location of a leaked block
	// set the parameter to the identifier for a leaked block
//	_CrtSetBreakAlloc();

////////////////////////////////////////////////////////////////////////////////////////////////
// LAB 4
////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "**********************************************************************\n";
	cout << "**              LAB 4: DOUBLY LINKED LIST AND ITERATOR              **\n";
	cout << "**********************************************************************\n\n";

	////////////////////////////////////////////////////////////////////////////////////////////
	// Declarations
	////////////////////////////////////////////////////////////////////////////////////////////
	DLList<string> list;
	DLList<string> list2;
	DLList<string>* list3;
	DLLIter<string> iter(list);
	DLList<int>* testPointer;

	////////////////////////////////////////////////////////////////////////////////////////////
	// TEST 1 - adding to the head and tail
	////////////////////////////////////////////////////////////////////////////////////////////
	cout << "*** TEST 1 ***\n\n";
	list.addHead("works");
	list.addHead("this");
	list.addHead("way");
	backward(list);
	list.clear();
	list.addTail("works");
	list.addTail("that");
	list.addTail("way");
	forward(list);
	list.clear();

	////////////////////////////////////////////////////////////////////////////////////////////
	// TEST 2 - insert and remove at various locations
	////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\n*** TEST 2 ***\n";
	list.addTail("end");
	list.addHead("is");
	iter.beginHead();
	list.insert(iter, "This");
	iter.beginTail();
	list.insert(iter, "the");
	list.insert(iter, "not");
	forward(list);
	list.remove(iter);
	forward(list);
	++iter;
	list.remove(iter);
	iter.beginHead();	
	while(!iter.end())
		list.remove(iter);	
	backward(list);
	
	////////////////////////////////////////////////////////////////////////////////////////////
	// TEST 3 - our old friend, the assignment operator
	////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\n*** TEST 3 ***\n";
	list.addHead("equal?");
	list.addHead("they");
	list.addHead("are");
	list2 = list;
	forward(list2);
	list2.clear();
	list = list2;
	backward(list);

	////////////////////////////////////////////////////////////////////////////////////////////
	// TEST 4 - let's do some stress testing of the list and iterator
	////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\n*** Test 4 ***\n";
	
	////////////////////////////////////////////////////////////////////////////////////////////
	// 4a
	////////////////////////////////////////////////////////////////////////////////////////////
	list.addHead("the next two printouts should be empty lists");
	forward(list);
	iter.beginHead();
	++iter;
	++iter;
	--iter;
	list.clear();

	////////////////////////////////////////////////////////////////////////////////////////////
	// 4b
	////////////////////////////////////////////////////////////////////////////////////////////
	iter.beginHead();
	list.insert(iter, "this should never get inserted");
	backward(list);
	iter.beginHead();
	list.remove(iter);
	forward(list);

	////////////////////////////////////////////////////////////////////////////////////////////
	// 4c
	////////////////////////////////////////////////////////////////////////////////////////////
	list.clear();
	list3 = &list;
	list.addHead("even I'm not sure why this is here");
	*list3 = list;
	backward(*list3);

	////////////////////////////////////////////////////////////////////////////////////////////
	// 4e
	////////////////////////////////////////////////////////////////////////////////////////////
	list.clear();
	list2.clear();
	list.addHead("have you covered all your bases?");
	list2.addHead("or will this node be leaked?");
	list2 = list;
	backward(list2);

	////////////////////////////////////////////////////////////////////////////////////////////
	// 4f
	////////////////////////////////////////////////////////////////////////////////////////////
	testPointer = new DLList<int>;
	for(int x = 0; x < 28; x+=4)
		testPointer->addHead(x);
	DLList<int> testCpyCtr(*testPointer);
	delete testPointer;
	forward(testCpyCtr);
	testCpyCtr.clear();
	backward(testCpyCtr);
	system("pause");
	////////////////////////////////////////////////////////////////////////////////////////////
	// Complete
	////////////////////////////////////////////////////////////////////////////////////////////
	return 0;

}